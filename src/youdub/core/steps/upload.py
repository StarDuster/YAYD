from __future__ import annotations

import json
import os
import shutil
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv
from loguru import logger

from ..interrupts import check_cancelled, sleep_with_cancel

load_dotenv()

try:
    import stream_gears  # type: ignore
except Exception as exc:  # noqa: BLE001 - keep best-effort import to avoid breaking non-upload features
    stream_gears = None  # type: ignore[assignment]
    _STREAM_GEARS_IMPORT_ERROR: Exception | None = exc
else:
    _STREAM_GEARS_IMPORT_ERROR = None


def _is_uploaded(submission_result: object) -> bool:
    if not isinstance(submission_result, dict):
        return False
    results = submission_result.get("results")
    if isinstance(results, list) and results and isinstance(results[0], dict):
        return results[0].get("code") == 0
    # Backward-compat for any custom markers.
    return submission_result.get("code") == 0


def _success_marker(payload: dict[str, object] | None = None) -> dict[str, object]:
    # Keep compatibility with pipeline._already_uploaded() which checks results[0].code == 0.
    out: dict[str, object] = {"results": [{"code": 0}]}
    if payload:
        out.update(payload)
    return out


def _cdn_to_upload_line(cdn: Optional[str]):
    if stream_gears is None:
        return None
    # Dynamically build mapping from available UploadLine members (PyPI version may differ from source).
    mapping: dict[str, object] = {}
    for name in ("Bda", "Bda2", "Tx", "Txa", "Bldsa", "Alia", "Qn"):
        if hasattr(stream_gears.UploadLine, name):
            mapping[name.lower()] = getattr(stream_gears.UploadLine, name)
    if not cdn:
        return None
    return mapping.get(cdn.strip().lower())


def _iter_upload_lines(preferred_cdn: Optional[str]) -> list[object | None]:
    # order: preferred -> auto(None) -> common fallbacks
    # keep small & predictable; avoid over-design
    fallbacks = ["bda2", "bda", "tx", "txa", "bldsa"]
    out: list[object | None] = []

    preferred_line = _cdn_to_upload_line(preferred_cdn)
    if preferred_line is not None:
        out.append(preferred_line)

    # auto selection
    out.append(None)

    # explicit fallbacks
    for cdn in fallbacks:
        line = _cdn_to_upload_line(cdn)
        if line is None:
            continue
        if line not in out:
            out.append(line)
    return out


def _ensure_cookie_file(cookie_path: Path) -> bool:
    try:
        cookie_path.parent.mkdir(parents=True, exist_ok=True)
    except Exception as exc:  # noqa: BLE001
        logger.error(f"创建cookie目录失败 {cookie_path.parent}: {exc}")
        return False

    try:
        if cookie_path.exists() and cookie_path.stat().st_size > 0:
            logger.info(f"使用现有B站cookie文件: {cookie_path}")
            return True
    except Exception:
        # If stat fails, just attempt re-login.
        pass

    # Prefer using an existing cookies.json generated by biliup login (or any other means).
    # We intentionally do NOT auto-login here (web cookies flow breaks frequently).
    candidate = cookie_path.parent / "cookies.json"
    try:
        if candidate.exists() and candidate.stat().st_size > 0:
            if candidate.resolve() != cookie_path.resolve():
                shutil.copy2(candidate, cookie_path)
                logger.info(f"已采用现有cookies.json -> {cookie_path}")
            else:
                logger.info(f"使用现有B站cookie文件: {cookie_path}")
            return True
    except Exception as exc:  # noqa: BLE001
        logger.warning(f"采用现有cookies.json失败: {exc}")

    return False


def _upload_video_with_biliup(
    folder: str,
    proxy: Optional[str],
    upload_cdn: Optional[str],
    cookie_path: Path,
) -> bool:
    check_cancelled()

    submission_result_path = os.path.join(folder, "bilibili.json")
    if os.path.exists(submission_result_path):
        try:
            with open(submission_result_path, "r", encoding="utf-8") as f:
                submission_result = json.load(f)
            if _is_uploaded(submission_result):
                logger.info("视频已上传")
                return True
        except Exception:
            # Corrupted marker -> proceed to upload.
            pass

    video_path = os.path.join(folder, "video.mp4")
    cover_path = os.path.join(folder, "video.png")
    if not os.path.exists(video_path):
        logger.warning(f"未找到视频文件: {video_path}")
        return False

    summary_path = os.path.join(folder, "summary.json")
    if not os.path.exists(summary_path):
        logger.warning(f"未找到摘要文件: {summary_path}")
        return False
    with open(summary_path, "r", encoding="utf-8") as f:
        summary = json.load(f)

    info_path = os.path.join(folder, "download.info.json")
    if not os.path.exists(info_path):
        logger.warning(f"未找到信息文件: {info_path}")
        return False
    with open(info_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    summary_title = summary.get("title", "Untitled").replace("视频标题：", "").strip()
    summary_text = summary.get("summary", "").replace("视频摘要：", "").replace("视频简介：", "").strip()

    tags = summary.get("tags", [])
    if not isinstance(tags, list):
        tags = []

    author = summary.get("author", "Unknown")
    title = f"【中配】{summary_title} - {author}"[:80]

    title_english = data.get("title", "")
    webpage_url = data.get("webpage_url", "")

    # Read model information for description
    translation_model = summary.get("translation_model", "")
    tts_method = ""
    tts_done_path = os.path.join(folder, ".tts_done.json")
    if os.path.exists(tts_done_path):
        try:
            with open(tts_done_path, "r", encoding="utf-8") as f:
                tts_done = json.load(f)
            tts_method = tts_done.get("tts_method", "")
        except Exception:
            pass

    # Build model info line
    model_info_parts = []
    if translation_model:
        model_info_parts.append(f"翻译模型: {translation_model}")
    if tts_method:
        tts_display = {"bytedance": "ByteDance TTS", "gemini": "Gemini TTS", "qwen": "Qwen3-TTS"}.get(tts_method, tts_method)
        model_info_parts.append(f"配音模型: {tts_display}")
    model_info_line = " | ".join(model_info_parts) if model_info_parts else ""

    # Note: webpage_url is already shown by Bilibili as "source" for reprinted videos (copyright=2),
    # so we don't include it in description to avoid duplication.
    description = (
        f"{title_english}\n{summary_text}\n\n"
        + (f"{model_info_line}\n" if model_info_line else "")
        + "项目地址：https://github.com/StarDuster/YAYD\n"
        "YAYD 是 YouDub-webui 的一个 fork，旨在将 YouTube 和其他平台上的高质量视频翻译和配音成中文版本。"
        "该工具结合了最新的 AI 技术，包括语音识别、大型语言模型翻译，以及 AI 声音克隆技术，"
        "提供与原视频相似的中文配音，为中文用户提供卓越的观看体验。"
    )

    base_tags = ["YouDub", author, "AI", "ChatGPT", "中文配音", "科学", "科普"]
    all_tags = base_tags + tags
    seen_tags: set[str] = set()
    final_tags: list[str] = []
    for t in all_tags:
        if not isinstance(t, str):
            continue
        if t not in seen_tags and len(t) <= 20:
            final_tags.append(t)
            seen_tags.add(t)
        if len(final_tags) >= 12:
            break

    try:
        if not cookie_path.exists() or cookie_path.stat().st_size <= 0:
            logger.error(
                f"B站cookie文件未找到或为空: {cookie_path}. "
                "请通过 `biliup login` 生成（会创建cookies.json），然后设置 BILI_COOKIE_PATH。"
            )
            return False
    except Exception as exc:  # noqa: BLE001
        logger.error(f"访问cookie文件失败 {cookie_path}: {exc}")
        return False

    # one upload attempt may still fail due to line/proxy/network; try a small set of lines
    attempts = 0
    for retry in range(5):
        check_cancelled()
        for line in _iter_upload_lines(upload_cdn):
            check_cancelled()
            attempts += 1
            try:
                line_name = getattr(line, "name", None) or str(line)
                logger.info(f"通过biliup上传中 (尝试 {attempts}, 重试 {retry+1}/5, 线路={line_name})")
                stream_gears.upload(  # type: ignore[union-attr]
                    video_path=[video_path],
                    cookie_file=str(cookie_path),
                    title=title,
                    tid=201,
                    tag=",".join(final_tags),
                    copyright=2,
                    source=str(webpage_url or ""),
                    desc=description,
                    cover=cover_path if os.path.exists(cover_path) else "",
                    line=line,
                    proxy=proxy,
                )

                # write a success marker compatible with pipeline._already_uploaded()
                with open(submission_result_path, "w", encoding="utf-8") as f:
                    json.dump(
                        _success_marker(
                            {
                                "tool": "biliup",
                                "title": title,
                                "tid": 201,
                                "tag": final_tags,
                                "source": webpage_url,
                            }
                        ),
                        f,
                        ensure_ascii=False,
                        indent=4,
                    )
                logger.info("上传成功")
                return True
            except Exception as exc:  # noqa: BLE001
                logger.exception(f"biliup上传失败: {exc}")
                msg = str(exc).lower()
                if "cookie" in msg or "csrf" in msg or "登录" in msg or "unauthorized" in msg:
                    logger.error(
                        "检测到可能的认证/cookie错误。 "
                        "请重新运行 `biliup login` 刷新cookies.json，然后重试。"
                    )
                    return False
                sleep_with_cancel(2)

        sleep_with_cancel(8)

    logger.error("重试后仍上传失败")
    return False


def upload_video(folder: str) -> bool:
    """Upload a single video folder (expects video.mp4 etc)."""
    if stream_gears is None:
        logger.error(f"stream_gears不可用。请安装依赖 'biliup'。({_STREAM_GEARS_IMPORT_ERROR})")
        return False

    proxy = (os.getenv("BILI_PROXY") or "").strip() or None
    upload_cdn = (os.getenv("BILI_UPLOAD_CDN") or "").strip() or None
    cookie_path = Path((os.getenv("BILI_COOKIE_PATH") or "bili_cookies.json").strip() or "bili_cookies.json")
    if not _ensure_cookie_file(cookie_path):
        logger.error(
            f"B站cookie文件未就绪: {cookie_path}。 "
            "通过 `biliup login` 生成（会创建cookies.json），然后设置 BILI_COOKIE_PATH。"
        )
        return False
    return _upload_video_with_biliup(folder, proxy, upload_cdn, cookie_path)


def upload_all_videos_under_folder(folder: str) -> str:
    if stream_gears is None:
        return f"错误：stream_gears 不可用。请安装依赖 'biliup'。({_STREAM_GEARS_IMPORT_ERROR})"

    proxy = (os.getenv("BILI_PROXY") or "").strip() or None
    upload_cdn = (os.getenv("BILI_UPLOAD_CDN") or "").strip() or None
    cookie_path = Path((os.getenv("BILI_COOKIE_PATH") or "bili_cookies.json").strip() or "bili_cookies.json")

    if proxy:
        logger.info(f"B站上传代理已配置: {proxy}")
    if upload_cdn:
        logger.info(f"B站首选上传CDN: {upload_cdn}")
    logger.info(f"B站cookie路径: {cookie_path}")

    # Prepare cookie file once to avoid repeated attempts for each video folder.
    if not _ensure_cookie_file(cookie_path):
        return (
            "错误：B站 cookie 未就绪。"
            "请先运行 `biliup login` 生成 cookies.json，再设置 BILI_COOKIE_PATH（或直接放在默认位置）。"
        )

    count = 0
    for root, _, files in os.walk(folder):
        check_cancelled()
        if "video.mp4" in files:
            if _upload_video_with_biliup(root, proxy, upload_cdn, cookie_path):
                count += 1
    return f"上传完成: {folder}（成功 {count} 个）"
